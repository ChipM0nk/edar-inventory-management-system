// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sales_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountSalesOrders = `-- name: CountSalesOrders :one
SELECT COUNT(*) FROM sales_orders
`

func (q *Queries) CountSalesOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountSalesOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountSalesOrdersWithFilter = `-- name: CountSalesOrdersWithFilter :one
SELECT COUNT(*)
FROM sales_orders so
WHERE ($1::text IS NULL OR so.status = $1)
  AND ($2::text IS NULL OR so.customer_name ILIKE '%' || $2 || '%')
  AND ($3::date IS NULL OR so.order_date >= $3)
  AND ($4::date IS NULL OR so.order_date <= $4)
`

type CountSalesOrdersWithFilterParams struct {
	Column1 string      `json:"column_1"`
	Column2 string      `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
	Column4 pgtype.Date `json:"column_4"`
}

func (q *Queries) CountSalesOrdersWithFilter(ctx context.Context, arg *CountSalesOrdersWithFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountSalesOrdersWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateSalesOrder = `-- name: CreateSalesOrder :one
INSERT INTO sales_orders (so_number, customer_name, customer_contact, order_date, expected_delivery_date, notes, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, so_number, customer_name, customer_contact, total_amount, status, order_date, expected_delivery_date, shipped_date, delivered_date, notes, created_by, created_at, updated_at
`

type CreateSalesOrderParams struct {
	SoNumber             string      `json:"so_number"`
	CustomerName         string      `json:"customer_name"`
	CustomerContact      *string     `json:"customer_contact"`
	OrderDate            pgtype.Date `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date `json:"expected_delivery_date"`
	Notes                *string     `json:"notes"`
	CreatedBy            pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateSalesOrder(ctx context.Context, arg *CreateSalesOrderParams) (*SalesOrder, error) {
	row := q.db.QueryRow(ctx, CreateSalesOrder,
		arg.SoNumber,
		arg.CustomerName,
		arg.CustomerContact,
		arg.OrderDate,
		arg.ExpectedDeliveryDate,
		arg.Notes,
		arg.CreatedBy,
	)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.SoNumber,
		&i.CustomerName,
		&i.CustomerContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ShippedDate,
		&i.DeliveredDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetSalesOrder = `-- name: GetSalesOrder :one
SELECT so.id, so.so_number, so.customer_name, so.customer_contact, so.total_amount, so.status, so.order_date, so.expected_delivery_date, so.shipped_date, so.delivered_date, so.notes, so.created_by, so.created_at, so.updated_at, u.first_name, u.last_name
FROM sales_orders so
JOIN users u ON so.created_by = u.id
WHERE so.id = $1
`

type GetSalesOrderRow struct {
	ID                   pgtype.UUID        `json:"id"`
	SoNumber             string             `json:"so_number"`
	CustomerName         string             `json:"customer_name"`
	CustomerContact      *string            `json:"customer_contact"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	Status               string             `json:"status"`
	OrderDate            pgtype.Date        `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date        `json:"expected_delivery_date"`
	ShippedDate          pgtype.Date        `json:"shipped_date"`
	DeliveredDate        pgtype.Date        `json:"delivered_date"`
	Notes                *string            `json:"notes"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
}

func (q *Queries) GetSalesOrder(ctx context.Context, id pgtype.UUID) (*GetSalesOrderRow, error) {
	row := q.db.QueryRow(ctx, GetSalesOrder, id)
	var i GetSalesOrderRow
	err := row.Scan(
		&i.ID,
		&i.SoNumber,
		&i.CustomerName,
		&i.CustomerContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ShippedDate,
		&i.DeliveredDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
	)
	return &i, err
}

const ListSalesOrders = `-- name: ListSalesOrders :many
SELECT so.id, so.so_number, so.customer_name, so.customer_contact, so.total_amount, so.status, so.order_date, so.expected_delivery_date, so.shipped_date, so.delivered_date, so.notes, so.created_by, so.created_at, so.updated_at, u.first_name, u.last_name
FROM sales_orders so
JOIN users u ON so.created_by = u.id
ORDER BY so.order_date DESC, so.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSalesOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSalesOrdersRow struct {
	ID                   pgtype.UUID        `json:"id"`
	SoNumber             string             `json:"so_number"`
	CustomerName         string             `json:"customer_name"`
	CustomerContact      *string            `json:"customer_contact"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	Status               string             `json:"status"`
	OrderDate            pgtype.Date        `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date        `json:"expected_delivery_date"`
	ShippedDate          pgtype.Date        `json:"shipped_date"`
	DeliveredDate        pgtype.Date        `json:"delivered_date"`
	Notes                *string            `json:"notes"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
}

func (q *Queries) ListSalesOrders(ctx context.Context, arg *ListSalesOrdersParams) ([]*ListSalesOrdersRow, error) {
	rows, err := q.db.Query(ctx, ListSalesOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSalesOrdersRow{}
	for rows.Next() {
		var i ListSalesOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.SoNumber,
			&i.CustomerName,
			&i.CustomerContact,
			&i.TotalAmount,
			&i.Status,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.ShippedDate,
			&i.DeliveredDate,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSalesOrdersWithFilter = `-- name: ListSalesOrdersWithFilter :many
SELECT so.id, so.so_number, so.customer_name, so.customer_contact, so.total_amount, so.status, so.order_date, so.expected_delivery_date, so.shipped_date, so.delivered_date, so.notes, so.created_by, so.created_at, so.updated_at, u.first_name, u.last_name
FROM sales_orders so
JOIN users u ON so.created_by = u.id
WHERE ($1::text IS NULL OR so.status = $1)
  AND ($2::text IS NULL OR so.customer_name ILIKE '%' || $2 || '%')
  AND ($3::date IS NULL OR so.order_date >= $3)
  AND ($4::date IS NULL OR so.order_date <= $4)
ORDER BY so.order_date DESC, so.created_at DESC
LIMIT $5 OFFSET $6
`

type ListSalesOrdersWithFilterParams struct {
	Column1 string      `json:"column_1"`
	Column2 string      `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
	Column4 pgtype.Date `json:"column_4"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListSalesOrdersWithFilterRow struct {
	ID                   pgtype.UUID        `json:"id"`
	SoNumber             string             `json:"so_number"`
	CustomerName         string             `json:"customer_name"`
	CustomerContact      *string            `json:"customer_contact"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	Status               string             `json:"status"`
	OrderDate            pgtype.Date        `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date        `json:"expected_delivery_date"`
	ShippedDate          pgtype.Date        `json:"shipped_date"`
	DeliveredDate        pgtype.Date        `json:"delivered_date"`
	Notes                *string            `json:"notes"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
}

func (q *Queries) ListSalesOrdersWithFilter(ctx context.Context, arg *ListSalesOrdersWithFilterParams) ([]*ListSalesOrdersWithFilterRow, error) {
	rows, err := q.db.Query(ctx, ListSalesOrdersWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSalesOrdersWithFilterRow{}
	for rows.Next() {
		var i ListSalesOrdersWithFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.SoNumber,
			&i.CustomerName,
			&i.CustomerContact,
			&i.TotalAmount,
			&i.Status,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.ShippedDate,
			&i.DeliveredDate,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSalesOrder = `-- name: UpdateSalesOrder :one
UPDATE sales_orders
SET customer_name = $2, customer_contact = $3, status = $4, expected_delivery_date = $5, shipped_date = $6, delivered_date = $7, notes = $8, updated_at = NOW()
WHERE id = $1
RETURNING id, so_number, customer_name, customer_contact, total_amount, status, order_date, expected_delivery_date, shipped_date, delivered_date, notes, created_by, created_at, updated_at
`

type UpdateSalesOrderParams struct {
	ID                   pgtype.UUID `json:"id"`
	CustomerName         string      `json:"customer_name"`
	CustomerContact      *string     `json:"customer_contact"`
	Status               string      `json:"status"`
	ExpectedDeliveryDate pgtype.Date `json:"expected_delivery_date"`
	ShippedDate          pgtype.Date `json:"shipped_date"`
	DeliveredDate        pgtype.Date `json:"delivered_date"`
	Notes                *string     `json:"notes"`
}

func (q *Queries) UpdateSalesOrder(ctx context.Context, arg *UpdateSalesOrderParams) (*SalesOrder, error) {
	row := q.db.QueryRow(ctx, UpdateSalesOrder,
		arg.ID,
		arg.CustomerName,
		arg.CustomerContact,
		arg.Status,
		arg.ExpectedDeliveryDate,
		arg.ShippedDate,
		arg.DeliveredDate,
		arg.Notes,
	)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.SoNumber,
		&i.CustomerName,
		&i.CustomerContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ShippedDate,
		&i.DeliveredDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSalesOrderTotal = `-- name: UpdateSalesOrderTotal :one
UPDATE sales_orders
SET total_amount = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, so_number, customer_name, customer_contact, total_amount, status, order_date, expected_delivery_date, shipped_date, delivered_date, notes, created_by, created_at, updated_at
`

type UpdateSalesOrderTotalParams struct {
	ID          pgtype.UUID    `json:"id"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) UpdateSalesOrderTotal(ctx context.Context, arg *UpdateSalesOrderTotalParams) (*SalesOrder, error) {
	row := q.db.QueryRow(ctx, UpdateSalesOrderTotal, arg.ID, arg.TotalAmount)
	var i SalesOrder
	err := row.Scan(
		&i.ID,
		&i.SoNumber,
		&i.CustomerName,
		&i.CustomerContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ShippedDate,
		&i.DeliveredDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
