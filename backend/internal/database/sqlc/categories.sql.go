// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountCategoriesWithFilter = `-- name: CountCategoriesWithFilter :one
SELECT COUNT(*) FROM categories
WHERE ($1::text IS NULL OR name ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR description ILIKE '%' || $2 || '%')
  AND ($3::boolean IS NULL OR is_active = $3)
`

type CountCategoriesWithFilterParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 bool   `json:"column_3"`
}

func (q *Queries) CountCategoriesWithFilter(ctx context.Context, arg *CountCategoriesWithFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountCategoriesWithFilter, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, description, is_active)
VALUES ($1, $2, $3)
RETURNING id, name, description, is_active, created_at, updated_at
`

type CreateCategoryParams struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
	IsActive    *bool   `json:"is_active"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg *CreateCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, CreateCategory, arg.Name, arg.Description, arg.IsActive)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteCategory = `-- name: DeleteCategory :exec
UPDATE categories
SET is_active = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteCategory, id)
	return err
}

const GetCategory = `-- name: GetCategory :one
SELECT id, name, description, is_active, created_at, updated_at FROM categories
WHERE id = $1
`

func (q *Queries) GetCategory(ctx context.Context, id pgtype.UUID) (*Category, error) {
	row := q.db.QueryRow(ctx, GetCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetCategoryByName = `-- name: GetCategoryByName :one
SELECT id, name, description, is_active, created_at, updated_at FROM categories
WHERE name = $1
`

func (q *Queries) GetCategoryByName(ctx context.Context, name string) (*Category, error) {
	row := q.db.QueryRow(ctx, GetCategoryByName, name)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListCategories = `-- name: ListCategories :many
SELECT id, name, description, is_active, created_at, updated_at FROM categories
WHERE is_active = true
ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]*Category, error) {
	rows, err := q.db.Query(ctx, ListCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCategoriesWithFilter = `-- name: ListCategoriesWithFilter :many
SELECT id, name, description, is_active, created_at, updated_at FROM categories
WHERE ($1::text = '' OR name ILIKE '%' || $1 || '%')
  AND ($2::text = '' OR description ILIKE '%' || $2 || '%')
  AND (is_active = $3)
ORDER BY 
  CASE WHEN $6 = 'name' AND $7 = 'asc' THEN name END ASC,
  CASE WHEN $6 = 'name' AND $7 = 'desc' THEN name END DESC,
  CASE WHEN $6 = 'created_at' AND $7 = 'asc' THEN created_at END ASC,
  CASE WHEN $6 = 'created_at' AND $7 = 'desc' THEN created_at END DESC
LIMIT $4 OFFSET $5
`

type ListCategoriesWithFilterParams struct {
	Column1  string      `json:"column_1"`
	Column2  string      `json:"column_2"`
	IsActive *bool       `json:"is_active"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Column6  interface{} `json:"column_6"`
	Column7  interface{} `json:"column_7"`
}

func (q *Queries) ListCategoriesWithFilter(ctx context.Context, arg *ListCategoriesWithFilterParams) ([]*Category, error) {
	rows, err := q.db.Query(ctx, ListCategoriesWithFilter,
		arg.Column1,
		arg.Column2,
		arg.IsActive,
		arg.Limit,
		arg.Offset,
		arg.Column6,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name = $2, description = $3, is_active = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, is_active, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	IsActive    *bool       `json:"is_active"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg *UpdateCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, UpdateCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsActive,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
