// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stock_levels.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountStockLevels = `-- name: CountStockLevels :one
SELECT COUNT(*) FROM stock_levels
`

func (q *Queries) CountStockLevels(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountStockLevels)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountStockLevelsWithFilter = `-- name: CountStockLevelsWithFilter :one
SELECT COUNT(*)
FROM stock_levels sl
JOIN products p ON sl.product_id = p.id
JOIN warehouses w ON sl.warehouse_id = w.id
WHERE ($1::uuid IS NULL OR sl.product_id = $1)
  AND ($2::uuid IS NULL OR sl.warehouse_id = $2)
  AND ($3::text IS NULL OR p.name ILIKE '%' || $3 || '%')
  AND ($4::text IS NULL OR p.sku ILIKE '%' || $4 || '%')
`

type CountStockLevelsWithFilterParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 string      `json:"column_4"`
}

func (q *Queries) CountStockLevelsWithFilter(ctx context.Context, arg *CountStockLevelsWithFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountStockLevelsWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateStockLevel = `-- name: CreateStockLevel :one
INSERT INTO stock_levels (product_id, warehouse_id, quantity, reserved_quantity, min_stock_level, max_stock_level)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, product_id, warehouse_id, quantity, reserved_quantity, available_quantity, min_stock_level, max_stock_level, last_updated, created_at, updated_at
`

type CreateStockLevelParams struct {
	ProductID        pgtype.UUID `json:"product_id"`
	WarehouseID      pgtype.UUID `json:"warehouse_id"`
	Quantity         int32       `json:"quantity"`
	ReservedQuantity int32       `json:"reserved_quantity"`
	MinStockLevel    *int32      `json:"min_stock_level"`
	MaxStockLevel    *int32      `json:"max_stock_level"`
}

func (q *Queries) CreateStockLevel(ctx context.Context, arg *CreateStockLevelParams) (*StockLevel, error) {
	row := q.db.QueryRow(ctx, CreateStockLevel,
		arg.ProductID,
		arg.WarehouseID,
		arg.Quantity,
		arg.ReservedQuantity,
		arg.MinStockLevel,
		arg.MaxStockLevel,
	)
	var i StockLevel
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetLowStockItems = `-- name: GetLowStockItems :many
SELECT sl.id, sl.product_id, sl.warehouse_id, sl.quantity, sl.reserved_quantity, sl.available_quantity, sl.min_stock_level, sl.max_stock_level, sl.last_updated, sl.created_at, sl.updated_at, p.name as product_name, p.sku, w.name as warehouse_name
FROM stock_levels sl
JOIN products p ON sl.product_id = p.id
JOIN warehouses w ON sl.warehouse_id = w.id
WHERE sl.available_quantity <= sl.min_stock_level
ORDER BY sl.available_quantity ASC
`

type GetLowStockItemsRow struct {
	ID                pgtype.UUID        `json:"id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	WarehouseID       pgtype.UUID        `json:"warehouse_id"`
	Quantity          int32              `json:"quantity"`
	ReservedQuantity  int32              `json:"reserved_quantity"`
	AvailableQuantity *int32             `json:"available_quantity"`
	MinStockLevel     *int32             `json:"min_stock_level"`
	MaxStockLevel     *int32             `json:"max_stock_level"`
	LastUpdated       pgtype.Timestamptz `json:"last_updated"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProductName       string             `json:"product_name"`
	Sku               string             `json:"sku"`
	WarehouseName     string             `json:"warehouse_name"`
}

func (q *Queries) GetLowStockItems(ctx context.Context) ([]*GetLowStockItemsRow, error) {
	rows, err := q.db.Query(ctx, GetLowStockItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLowStockItemsRow{}
	for rows.Next() {
		var i GetLowStockItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.WarehouseID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.AvailableQuantity,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetStockLevel = `-- name: GetStockLevel :one
SELECT sl.id, sl.product_id, sl.warehouse_id, sl.quantity, sl.reserved_quantity, sl.available_quantity, sl.min_stock_level, sl.max_stock_level, sl.last_updated, sl.created_at, sl.updated_at, p.name as product_name, p.sku, w.name as warehouse_name
FROM stock_levels sl
JOIN products p ON sl.product_id = p.id
JOIN warehouses w ON sl.warehouse_id = w.id
WHERE sl.product_id = $1 AND sl.warehouse_id = $2
`

type GetStockLevelParams struct {
	ProductID   pgtype.UUID `json:"product_id"`
	WarehouseID pgtype.UUID `json:"warehouse_id"`
}

type GetStockLevelRow struct {
	ID                pgtype.UUID        `json:"id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	WarehouseID       pgtype.UUID        `json:"warehouse_id"`
	Quantity          int32              `json:"quantity"`
	ReservedQuantity  int32              `json:"reserved_quantity"`
	AvailableQuantity *int32             `json:"available_quantity"`
	MinStockLevel     *int32             `json:"min_stock_level"`
	MaxStockLevel     *int32             `json:"max_stock_level"`
	LastUpdated       pgtype.Timestamptz `json:"last_updated"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProductName       string             `json:"product_name"`
	Sku               string             `json:"sku"`
	WarehouseName     string             `json:"warehouse_name"`
}

func (q *Queries) GetStockLevel(ctx context.Context, arg *GetStockLevelParams) (*GetStockLevelRow, error) {
	row := q.db.QueryRow(ctx, GetStockLevel, arg.ProductID, arg.WarehouseID)
	var i GetStockLevelRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductName,
		&i.Sku,
		&i.WarehouseName,
	)
	return &i, err
}

const ListStockLevels = `-- name: ListStockLevels :many
SELECT sl.id, sl.product_id, sl.warehouse_id, sl.quantity, sl.reserved_quantity, sl.available_quantity, sl.min_stock_level, sl.max_stock_level, sl.last_updated, sl.created_at, sl.updated_at, p.name as product_name, p.sku, w.name as warehouse_name
FROM stock_levels sl
JOIN products p ON sl.product_id = p.id
JOIN warehouses w ON sl.warehouse_id = w.id
ORDER BY p.name, w.name
LIMIT $1 OFFSET $2
`

type ListStockLevelsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListStockLevelsRow struct {
	ID                pgtype.UUID        `json:"id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	WarehouseID       pgtype.UUID        `json:"warehouse_id"`
	Quantity          int32              `json:"quantity"`
	ReservedQuantity  int32              `json:"reserved_quantity"`
	AvailableQuantity *int32             `json:"available_quantity"`
	MinStockLevel     *int32             `json:"min_stock_level"`
	MaxStockLevel     *int32             `json:"max_stock_level"`
	LastUpdated       pgtype.Timestamptz `json:"last_updated"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProductName       string             `json:"product_name"`
	Sku               string             `json:"sku"`
	WarehouseName     string             `json:"warehouse_name"`
}

func (q *Queries) ListStockLevels(ctx context.Context, arg *ListStockLevelsParams) ([]*ListStockLevelsRow, error) {
	rows, err := q.db.Query(ctx, ListStockLevels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStockLevelsRow{}
	for rows.Next() {
		var i ListStockLevelsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.WarehouseID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.AvailableQuantity,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListStockLevelsWithFilter = `-- name: ListStockLevelsWithFilter :many
SELECT sl.id, sl.product_id, sl.warehouse_id, sl.quantity, sl.reserved_quantity, sl.available_quantity, sl.min_stock_level, sl.max_stock_level, sl.last_updated, sl.created_at, sl.updated_at, p.name as product_name, p.sku, w.name as warehouse_name
FROM stock_levels sl
JOIN products p ON sl.product_id = p.id
JOIN warehouses w ON sl.warehouse_id = w.id
WHERE ($1::uuid IS NULL OR sl.product_id = $1)
  AND ($2::uuid IS NULL OR sl.warehouse_id = $2)
  AND ($3::text IS NULL OR p.name ILIKE '%' || $3 || '%')
  AND ($4::text IS NULL OR p.sku ILIKE '%' || $4 || '%')
ORDER BY p.name, w.name
LIMIT $5 OFFSET $6
`

type ListStockLevelsWithFilterParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 string      `json:"column_4"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListStockLevelsWithFilterRow struct {
	ID                pgtype.UUID        `json:"id"`
	ProductID         pgtype.UUID        `json:"product_id"`
	WarehouseID       pgtype.UUID        `json:"warehouse_id"`
	Quantity          int32              `json:"quantity"`
	ReservedQuantity  int32              `json:"reserved_quantity"`
	AvailableQuantity *int32             `json:"available_quantity"`
	MinStockLevel     *int32             `json:"min_stock_level"`
	MaxStockLevel     *int32             `json:"max_stock_level"`
	LastUpdated       pgtype.Timestamptz `json:"last_updated"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	ProductName       string             `json:"product_name"`
	Sku               string             `json:"sku"`
	WarehouseName     string             `json:"warehouse_name"`
}

func (q *Queries) ListStockLevelsWithFilter(ctx context.Context, arg *ListStockLevelsWithFilterParams) ([]*ListStockLevelsWithFilterRow, error) {
	rows, err := q.db.Query(ctx, ListStockLevelsWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStockLevelsWithFilterRow{}
	for rows.Next() {
		var i ListStockLevelsWithFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.WarehouseID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.AvailableQuantity,
			&i.MinStockLevel,
			&i.MaxStockLevel,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
			&i.WarehouseName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateReservedQuantity = `-- name: UpdateReservedQuantity :one
UPDATE stock_levels
SET reserved_quantity = $3, last_updated = NOW(), updated_at = NOW()
WHERE product_id = $1 AND warehouse_id = $2
RETURNING id, product_id, warehouse_id, quantity, reserved_quantity, available_quantity, min_stock_level, max_stock_level, last_updated, created_at, updated_at
`

type UpdateReservedQuantityParams struct {
	ProductID        pgtype.UUID `json:"product_id"`
	WarehouseID      pgtype.UUID `json:"warehouse_id"`
	ReservedQuantity int32       `json:"reserved_quantity"`
}

func (q *Queries) UpdateReservedQuantity(ctx context.Context, arg *UpdateReservedQuantityParams) (*StockLevel, error) {
	row := q.db.QueryRow(ctx, UpdateReservedQuantity, arg.ProductID, arg.WarehouseID, arg.ReservedQuantity)
	var i StockLevel
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateStockLevel = `-- name: UpdateStockLevel :one
UPDATE stock_levels
SET quantity = $3, reserved_quantity = $4, min_stock_level = $5, max_stock_level = $6, last_updated = NOW(), updated_at = NOW()
WHERE product_id = $1 AND warehouse_id = $2
RETURNING id, product_id, warehouse_id, quantity, reserved_quantity, available_quantity, min_stock_level, max_stock_level, last_updated, created_at, updated_at
`

type UpdateStockLevelParams struct {
	ProductID        pgtype.UUID `json:"product_id"`
	WarehouseID      pgtype.UUID `json:"warehouse_id"`
	Quantity         int32       `json:"quantity"`
	ReservedQuantity int32       `json:"reserved_quantity"`
	MinStockLevel    *int32      `json:"min_stock_level"`
	MaxStockLevel    *int32      `json:"max_stock_level"`
}

func (q *Queries) UpdateStockLevel(ctx context.Context, arg *UpdateStockLevelParams) (*StockLevel, error) {
	row := q.db.QueryRow(ctx, UpdateStockLevel,
		arg.ProductID,
		arg.WarehouseID,
		arg.Quantity,
		arg.ReservedQuantity,
		arg.MinStockLevel,
		arg.MaxStockLevel,
	)
	var i StockLevel
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateStockQuantity = `-- name: UpdateStockQuantity :one
UPDATE stock_levels
SET quantity = $3, last_updated = NOW(), updated_at = NOW()
WHERE product_id = $1 AND warehouse_id = $2
RETURNING id, product_id, warehouse_id, quantity, reserved_quantity, available_quantity, min_stock_level, max_stock_level, last_updated, created_at, updated_at
`

type UpdateStockQuantityParams struct {
	ProductID   pgtype.UUID `json:"product_id"`
	WarehouseID pgtype.UUID `json:"warehouse_id"`
	Quantity    int32       `json:"quantity"`
}

func (q *Queries) UpdateStockQuantity(ctx context.Context, arg *UpdateStockQuantityParams) (*StockLevel, error) {
	row := q.db.QueryRow(ctx, UpdateStockQuantity, arg.ProductID, arg.WarehouseID, arg.Quantity)
	var i StockLevel
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.WarehouseID,
		&i.Quantity,
		&i.ReservedQuantity,
		&i.AvailableQuantity,
		&i.MinStockLevel,
		&i.MaxStockLevel,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
