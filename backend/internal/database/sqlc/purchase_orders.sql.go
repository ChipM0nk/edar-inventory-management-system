// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: purchase_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountPurchaseOrders = `-- name: CountPurchaseOrders :one
SELECT COUNT(*) FROM purchase_orders
`

func (q *Queries) CountPurchaseOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountPurchaseOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountPurchaseOrdersWithFilter = `-- name: CountPurchaseOrdersWithFilter :one
SELECT COUNT(*)
FROM purchase_orders po
WHERE ($1::text IS NULL OR po.status = $1)
  AND ($2::text IS NULL OR po.supplier_name ILIKE '%' || $2 || '%')
  AND ($3::date IS NULL OR po.order_date >= $3)
  AND ($4::date IS NULL OR po.order_date <= $4)
`

type CountPurchaseOrdersWithFilterParams struct {
	Column1 string      `json:"column_1"`
	Column2 string      `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
	Column4 pgtype.Date `json:"column_4"`
}

func (q *Queries) CountPurchaseOrdersWithFilter(ctx context.Context, arg *CountPurchaseOrdersWithFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountPurchaseOrdersWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreatePurchaseOrder = `-- name: CreatePurchaseOrder :one
INSERT INTO purchase_orders (po_number, supplier_name, supplier_contact, order_date, expected_delivery_date, notes, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, po_number, supplier_name, supplier_contact, total_amount, status, order_date, expected_delivery_date, received_date, notes, created_by, created_at, updated_at
`

type CreatePurchaseOrderParams struct {
	PoNumber             string      `json:"po_number"`
	SupplierName         string      `json:"supplier_name"`
	SupplierContact      *string     `json:"supplier_contact"`
	OrderDate            pgtype.Date `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date `json:"expected_delivery_date"`
	Notes                *string     `json:"notes"`
	CreatedBy            pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg *CreatePurchaseOrderParams) (*PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, CreatePurchaseOrder,
		arg.PoNumber,
		arg.SupplierName,
		arg.SupplierContact,
		arg.OrderDate,
		arg.ExpectedDeliveryDate,
		arg.Notes,
		arg.CreatedBy,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.PoNumber,
		&i.SupplierName,
		&i.SupplierContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ReceivedDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetPurchaseOrder = `-- name: GetPurchaseOrder :one
SELECT po.id, po.po_number, po.supplier_name, po.supplier_contact, po.total_amount, po.status, po.order_date, po.expected_delivery_date, po.received_date, po.notes, po.created_by, po.created_at, po.updated_at, u.first_name, u.last_name
FROM purchase_orders po
JOIN users u ON po.created_by = u.id
WHERE po.id = $1
`

type GetPurchaseOrderRow struct {
	ID                   pgtype.UUID        `json:"id"`
	PoNumber             string             `json:"po_number"`
	SupplierName         string             `json:"supplier_name"`
	SupplierContact      *string            `json:"supplier_contact"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	Status               string             `json:"status"`
	OrderDate            pgtype.Date        `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date        `json:"expected_delivery_date"`
	ReceivedDate         pgtype.Date        `json:"received_date"`
	Notes                *string            `json:"notes"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
}

func (q *Queries) GetPurchaseOrder(ctx context.Context, id pgtype.UUID) (*GetPurchaseOrderRow, error) {
	row := q.db.QueryRow(ctx, GetPurchaseOrder, id)
	var i GetPurchaseOrderRow
	err := row.Scan(
		&i.ID,
		&i.PoNumber,
		&i.SupplierName,
		&i.SupplierContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ReceivedDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
	)
	return &i, err
}

const ListPurchaseOrders = `-- name: ListPurchaseOrders :many
SELECT po.id, po.po_number, po.supplier_name, po.supplier_contact, po.total_amount, po.status, po.order_date, po.expected_delivery_date, po.received_date, po.notes, po.created_by, po.created_at, po.updated_at, u.first_name, u.last_name
FROM purchase_orders po
JOIN users u ON po.created_by = u.id
ORDER BY po.order_date DESC, po.created_at DESC
LIMIT $1 OFFSET $2
`

type ListPurchaseOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPurchaseOrdersRow struct {
	ID                   pgtype.UUID        `json:"id"`
	PoNumber             string             `json:"po_number"`
	SupplierName         string             `json:"supplier_name"`
	SupplierContact      *string            `json:"supplier_contact"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	Status               string             `json:"status"`
	OrderDate            pgtype.Date        `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date        `json:"expected_delivery_date"`
	ReceivedDate         pgtype.Date        `json:"received_date"`
	Notes                *string            `json:"notes"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
}

func (q *Queries) ListPurchaseOrders(ctx context.Context, arg *ListPurchaseOrdersParams) ([]*ListPurchaseOrdersRow, error) {
	rows, err := q.db.Query(ctx, ListPurchaseOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPurchaseOrdersRow{}
	for rows.Next() {
		var i ListPurchaseOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.PoNumber,
			&i.SupplierName,
			&i.SupplierContact,
			&i.TotalAmount,
			&i.Status,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.ReceivedDate,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPurchaseOrdersWithFilter = `-- name: ListPurchaseOrdersWithFilter :many
SELECT po.id, po.po_number, po.supplier_name, po.supplier_contact, po.total_amount, po.status, po.order_date, po.expected_delivery_date, po.received_date, po.notes, po.created_by, po.created_at, po.updated_at, u.first_name, u.last_name
FROM purchase_orders po
JOIN users u ON po.created_by = u.id
WHERE ($1::text IS NULL OR po.status = $1)
  AND ($2::text IS NULL OR po.supplier_name ILIKE '%' || $2 || '%')
  AND ($3::date IS NULL OR po.order_date >= $3)
  AND ($4::date IS NULL OR po.order_date <= $4)
ORDER BY po.order_date DESC, po.created_at DESC
LIMIT $5 OFFSET $6
`

type ListPurchaseOrdersWithFilterParams struct {
	Column1 string      `json:"column_1"`
	Column2 string      `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
	Column4 pgtype.Date `json:"column_4"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListPurchaseOrdersWithFilterRow struct {
	ID                   pgtype.UUID        `json:"id"`
	PoNumber             string             `json:"po_number"`
	SupplierName         string             `json:"supplier_name"`
	SupplierContact      *string            `json:"supplier_contact"`
	TotalAmount          pgtype.Numeric     `json:"total_amount"`
	Status               string             `json:"status"`
	OrderDate            pgtype.Date        `json:"order_date"`
	ExpectedDeliveryDate pgtype.Date        `json:"expected_delivery_date"`
	ReceivedDate         pgtype.Date        `json:"received_date"`
	Notes                *string            `json:"notes"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
}

func (q *Queries) ListPurchaseOrdersWithFilter(ctx context.Context, arg *ListPurchaseOrdersWithFilterParams) ([]*ListPurchaseOrdersWithFilterRow, error) {
	rows, err := q.db.Query(ctx, ListPurchaseOrdersWithFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPurchaseOrdersWithFilterRow{}
	for rows.Next() {
		var i ListPurchaseOrdersWithFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.PoNumber,
			&i.SupplierName,
			&i.SupplierContact,
			&i.TotalAmount,
			&i.Status,
			&i.OrderDate,
			&i.ExpectedDeliveryDate,
			&i.ReceivedDate,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePurchaseOrder = `-- name: UpdatePurchaseOrder :one
UPDATE purchase_orders
SET supplier_name = $2, supplier_contact = $3, status = $4, expected_delivery_date = $5, received_date = $6, notes = $7, updated_at = NOW()
WHERE id = $1
RETURNING id, po_number, supplier_name, supplier_contact, total_amount, status, order_date, expected_delivery_date, received_date, notes, created_by, created_at, updated_at
`

type UpdatePurchaseOrderParams struct {
	ID                   pgtype.UUID `json:"id"`
	SupplierName         string      `json:"supplier_name"`
	SupplierContact      *string     `json:"supplier_contact"`
	Status               string      `json:"status"`
	ExpectedDeliveryDate pgtype.Date `json:"expected_delivery_date"`
	ReceivedDate         pgtype.Date `json:"received_date"`
	Notes                *string     `json:"notes"`
}

func (q *Queries) UpdatePurchaseOrder(ctx context.Context, arg *UpdatePurchaseOrderParams) (*PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, UpdatePurchaseOrder,
		arg.ID,
		arg.SupplierName,
		arg.SupplierContact,
		arg.Status,
		arg.ExpectedDeliveryDate,
		arg.ReceivedDate,
		arg.Notes,
	)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.PoNumber,
		&i.SupplierName,
		&i.SupplierContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ReceivedDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdatePurchaseOrderTotal = `-- name: UpdatePurchaseOrderTotal :one
UPDATE purchase_orders
SET total_amount = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, po_number, supplier_name, supplier_contact, total_amount, status, order_date, expected_delivery_date, received_date, notes, created_by, created_at, updated_at
`

type UpdatePurchaseOrderTotalParams struct {
	ID          pgtype.UUID    `json:"id"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) UpdatePurchaseOrderTotal(ctx context.Context, arg *UpdatePurchaseOrderTotalParams) (*PurchaseOrder, error) {
	row := q.db.QueryRow(ctx, UpdatePurchaseOrderTotal, arg.ID, arg.TotalAmount)
	var i PurchaseOrder
	err := row.Scan(
		&i.ID,
		&i.PoNumber,
		&i.SupplierName,
		&i.SupplierContact,
		&i.TotalAmount,
		&i.Status,
		&i.OrderDate,
		&i.ExpectedDeliveryDate,
		&i.ReceivedDate,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
