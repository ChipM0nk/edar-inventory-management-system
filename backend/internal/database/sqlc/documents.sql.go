// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: documents.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateDocument = `-- name: CreateDocument :one
INSERT INTO documents (
    purchase_order_id,
    file_name,
    file_path,
    file_size,
    file_type,
    validation_status
) VALUES (
    $1, $2, $3, $4, $5, 'pending'
) RETURNING id, purchase_order_id, file_name, file_path, file_size, file_type, uploaded_at, created_at, updated_at, has_po_reference, has_matching_date, validation_status, validation_notes
`

type CreateDocumentParams struct {
	PurchaseOrderID pgtype.UUID `json:"purchase_order_id"`
	FileName        string      `json:"file_name"`
	FilePath        string      `json:"file_path"`
	FileSize        int64       `json:"file_size"`
	FileType        string      `json:"file_type"`
}

func (q *Queries) CreateDocument(ctx context.Context, arg *CreateDocumentParams) (*Document, error) {
	row := q.db.QueryRow(ctx, CreateDocument,
		arg.PurchaseOrderID,
		arg.FileName,
		arg.FilePath,
		arg.FileSize,
		arg.FileType,
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.FileType,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HasPoReference,
		&i.HasMatchingDate,
		&i.ValidationStatus,
		&i.ValidationNotes,
	)
	return &i, err
}

const DeleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents WHERE id = $1
`

func (q *Queries) DeleteDocument(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteDocument, id)
	return err
}

const GetDocumentByID = `-- name: GetDocumentByID :one
SELECT id, purchase_order_id, file_name, file_path, file_size, file_type, uploaded_at, created_at, updated_at, has_po_reference, has_matching_date, validation_status, validation_notes FROM documents WHERE id = $1
`

func (q *Queries) GetDocumentByID(ctx context.Context, id pgtype.UUID) (*Document, error) {
	row := q.db.QueryRow(ctx, GetDocumentByID, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.FileType,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HasPoReference,
		&i.HasMatchingDate,
		&i.ValidationStatus,
		&i.ValidationNotes,
	)
	return &i, err
}

const GetDocumentsByPurchaseOrder = `-- name: GetDocumentsByPurchaseOrder :many
SELECT id, purchase_order_id, file_name, file_path, file_size, file_type, uploaded_at, created_at, updated_at, has_po_reference, has_matching_date, validation_status, validation_notes FROM documents 
WHERE purchase_order_id = $1 
ORDER BY uploaded_at DESC
`

func (q *Queries) GetDocumentsByPurchaseOrder(ctx context.Context, purchaseOrderID pgtype.UUID) ([]*Document, error) {
	rows, err := q.db.Query(ctx, GetDocumentsByPurchaseOrder, purchaseOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Document{}
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.PurchaseOrderID,
			&i.FileName,
			&i.FilePath,
			&i.FileSize,
			&i.FileType,
			&i.UploadedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HasPoReference,
			&i.HasMatchingDate,
			&i.ValidationStatus,
			&i.ValidationNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateDocumentValidation = `-- name: UpdateDocumentValidation :one
UPDATE documents 
SET has_po_reference = $2, 
    has_matching_date = $3, 
    validation_status = $4, 
    validation_notes = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, purchase_order_id, file_name, file_path, file_size, file_type, uploaded_at, created_at, updated_at, has_po_reference, has_matching_date, validation_status, validation_notes
`

type UpdateDocumentValidationParams struct {
	ID               pgtype.UUID `json:"id"`
	HasPoReference   *bool       `json:"has_po_reference"`
	HasMatchingDate  *bool       `json:"has_matching_date"`
	ValidationStatus *string     `json:"validation_status"`
	ValidationNotes  *string     `json:"validation_notes"`
}

func (q *Queries) UpdateDocumentValidation(ctx context.Context, arg *UpdateDocumentValidationParams) (*Document, error) {
	row := q.db.QueryRow(ctx, UpdateDocumentValidation,
		arg.ID,
		arg.HasPoReference,
		arg.HasMatchingDate,
		arg.ValidationStatus,
		arg.ValidationNotes,
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.PurchaseOrderID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.FileType,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HasPoReference,
		&i.HasMatchingDate,
		&i.ValidationStatus,
		&i.ValidationNotes,
	)
	return &i, err
}
